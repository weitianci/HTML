#HTML5
##语义化标签
	>`hgroup`：对整个页面/页面中的一个内容区块的标题进行组合
	>`header`：一个内容区块或整个页面的头部部分
	>`main`：整个页面中间主体的部分
	>`footer`：页面的尾部
	>`nav`：页面中导航链接的部分
	>`article`：文章区域，定义可以独立于内容其余部分的完整独立内容块，`article`元素就是专门为摘要设计的，比如一篇文章
	>`aside`：表示`article`标签内容之外的，与`article`标签内容相关的辅助信息，`aside`元素应该被用于无关内容。（例如：广告）
	>- 如果你有你认为应该与主内容分开的内容，那么`aside`元素是你应该正确考虑使用的元素
	>- 询问你自己`aside`元素中的内容是否可以被独立开来而不会影响文档或者`section`中主内容的含义。
	>- 可以用在主要内容相关的引用，侧边栏，广告，`nav`元素组等。
	>- 简单来说：`aside`的内容如果被删除，剩下的内容仍然很合理
	>`figure`：
	>- 表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元
	>- `figure`：配图区域
	>`figcaption`:
	>- 代表一个图例的说明
	>- 代表了`figure`元素的一个标题或者说是其相关解释
	>- 在使用`figcaption`时，它最好是`figure`块的第一个或者最后一个元素
	>- `mark`：标记
	>- `time`：时间标记
	>- `progress`：进度条

>`audio`：视频标签
	>属性
	>`duration`：播放的总时间（s）
	>`currentTime`：当前已经播放的时间（s）
	>`ended`：是否已经播放完成
	>`paused`：当前是否为暂停状态
	>`volume`：控制音量（0~1）
	>方法
	>`pause()`：暂停
	>`play()`：播放
	>事件
	>`canplay`：可以正常播放（但是播放过程中可能出现卡顿）
	>`canplaythrough`：资源加载完毕，可以顺畅的播放
	>`ended`：播放完成
	>`loadedmetadata`：资源的基础信息已经加载完成
	>`loadeddata`：整个资源都加载完成
	>`pause`：触发了暂停
	>`play`：触发了播放
	>`playing`：正在播放中

	>`video`：音频标签
	>`canvas`：图形绘制标签

	>API：
	>本地存储：`localStorage/sessionStorge`
	>获取地理位置：`navigator.geolocation.getCurrentPosition`
	>（调取手机内部的GPS定位系统获取当前手机所在地的经纬度以及精准度等）
	>`websocket:socket.io`：客户端和服务器端新的传输方式（即时通讯IM系统基本上很多是基于它完成的）

##新增input元素的种类
	>`search`：搜索输入框
	>`tel`：电话号码输入框
	>`url`：输入`url`地址
	>`email`：邮件输入框

	>`number`：pc端-数字输入框    手机端-数字虚拟键盘
	>`range`：特定范围内的数值选择器（通过拖动滚动条改变一定范围内的数字）
	```
	//通过滑动range改变number的值
	<input type="number" id="ageInp" step="1" max="65" min="10" value="25" disabled>
	<input type="range" id="rangeInp" step="1" max="65" min="10" value="25">
	<script>
		rangeInp.oninput = function(){
			let val=this.value;
			ageInp.value=val;
		}
	</script>
	```
	>html：
		>`step`：数值每次增加1    
		>`max`：最大值65    
		>`min`：最小值10   
		>`value`：默认值25   
		>`disabled`：取消默认样式（例如：取消`number`的上下箭头）

	>js：
		>`oninput`：当元素获得用户输入时同步运行脚本   
		>`onChange`：选框改变时的事件
		>`onblur`：失去焦点
		>`onfocus`：获取焦点

		>`color`：颜色选取器
		>`datetime-local`：显示完整日期和时间
		>`date`：显示日期
		>`time`：显示时间
		>`month`：显示月
		>`week`：显示周

##表单新特性
	>`placeholder`：输入框占位符，常用作输入提示，输入数据时，提示自动消失
	>`autocomplete`：是否保存用户输入值，默认为`on`，关闭提示选择`off`
	>`autofocus`：自动聚焦
	>`required`：表单此项必填，不能为空
	>`pattern`：正则验证`pattern="\d{1,5}"`
	>`form`属性只要加上`form`属性，表单元素可以放到页面的任意位置。
	>`formnovalidate`和`novalidate`：
	>- 它俩都表示不需要验证表单，直接提交：`novalidate`用于`form`标签；
	>- `formnovalidate`用于`submit`类型的提交按钮。

##表单验证
	>`validity`对象，通过下面的`valid`可以查看验证是否通过
	>`oText.addEventListener`：(`“invalid",fn1,false`);

	>`outline:none`：当文本框获取焦点后取出浏览器默认的边框选中颜色
	>`valid`：验证通过
	>`#id.valid{color:#ccc}`
	>`#id:valid+span:after{content:'格式正确'}`
	>`invalid`：验证不通过
	>`#id.valid{color:red}`
	>`#id:invalid+span:after{content:'格式不正确'}`

	>`valueMissing`：输入值为空时
	>`typeMismatch`：控件值与预期类型不匹配
	>`patternMismatch`：输入值不满足`pattern`正则
	>`customError`：不符合自定义验证
	>`setCustomValidity();`：自定义验证

#CSS 3
##选择器
	>`*`
	>`id`
	>`class`
	>`tag`
	>`selector1,selector2...`：群组选择器
	>`A .B{}`：后代选择器
	>`A.B{}`：即具备A也具备B（同级二次筛选）
	>`A>B{}`：子代选择器
	>`A+B{}`：A元素下的B元素
	>`A~B{}`：兄弟选择器
	>`A[name='']`：属性选择器
	>`A[name!='']`：除了某个元素的其它元素
	>`A[name^='']`：以某个元素开始
	>`A[name$='']`：以某个元素结尾
	>`A[name*='']`：包含哪个元素
	>`A:hover`
	>`A:active`
	>`A:after`
	>`A:before`
	>`A:nth-child(1)`
	>`A:nth-last-child(1)`
	>`A:nth-of-type()`
	>`A:nth-last-of-type()`
	>`A:not`
	>`A:first-child`
	>`A:last-child`

##样式属性
	>`border-radius`：盒子圆角
	>`box-shadow`：盒子阴影
	>`text-shadow`：文本阴影
	>`background-color`：背景颜色
	>`background-image`：背景图片
	>`background-position`：获取图片的某一位置部分
	>`background-repet`：平铺
	>`background-norepet`：不平铺
	>`background-size:x,y`：宽高
	>`background-size:cover`：图片缩放覆盖所在容器不变形
	>`background-size:contain`：背景图覆盖整个内容区域（如果一边碰到容器边缘，则会停止覆盖，导致部分区域没有背景图）
	>`background-attachment`：背景图固定地位
	>`background-clip`：背景图片裁切
	>`background-clip:border-box`：从边框开始裁切
	>`background-clip:padding-box`：从padding开始裁切
	>`background-clip:content-box`：从内容开始裁切
	>`background-origin`：设置背景图的起始点
	>`background-origin:border-box`：以边框为起始点
	>`background-origin:padding-box`：以边padding起始点
	>`background-origin:content-box`：以内容为起始点
	>`filter`：过滤

>CSS 3 
	>动画和变形（2D/3D）
	>`transform:translate(x,y,z)`：位移
	>`transform:scale`：缩放
	>`transform:rotate`：旋转
	>`transform:matrix`：矩阵(按照自己设定的矩阵公式实现变形)
	>`transform-style:preserve-3d`：实现3D变形
	>`transform-origin`：变形的起点

	>过渡动画
	>`transition-property:all/width`：那些属性样式发生改变执行过渡动画效果，默认all，所有样式属性改变都会执行这个过渡效果
	>`transition-timing-function`：动画运动的方式
	>`transition-timing-function:linear`（默认）
	>`transition-timing-function:ease`
	>`transition-timing-function:ease-in` 
	>`transition-timing-function:ease-out` 
	>`transition-timing-function:ease-in-out` 
	>`transition-timing-function:cubic-bezier`：执行自己设定的贝赛尔曲线
	>`transition-delay`：设置延迟的时间，默认是`0s`不延迟，立即执行动画

	>帧动画
	>`animation-name`：运动轨迹的名称
	>`animation-duration`：运动的时长
	>`animation-timing-function`：运动的方式（默认`ease`）
	>`animation-delay`：延迟时间
	>`animation-iteration-count`：运动次数（默认1 `infinite`无限次运动）
	>`animation-fill-mode`：运动完成后的状态
	>`animation-fill-mode:forwards`：帧动画完成后，让其停留在最后一帧的位置（元素会默认回到运动的起始位置）
	>`animation-fill-mode:backwards`：当前帧动画如果有延迟时间，在延迟等待时间内，元素处于帧动画的第一帧位置
	>`animation-fill-mode:both`：让帧动画同时具备`forwards`和`backwards`
	>设置运动轨迹
	```
	keyframes name(animation-name设置的名称){
		from{
			//开始的样式
		}
		to{
			//结束的样式
		}
	}
	keyframes name{
		0%{
			//开始的样式
		}
		50%{
			//过程中的样式
		}
		100%{
			//开始的样式
		}
	}
	```

>CSS 3 中的新盒子模型
	>`columns`：多列布局
	>`flex`：弹性盒子模型
	>`box-sizing:border-box`：代表整个盒子的宽高
	>`box-sizing:padding-box`：代表盒子的大小不变padding的宽高
	>`box-sizing:content-box`：代表盒子大小不变内容的宽高（默认值）
	>`perspective`：视距（实现3D动画必用的属性）
	>`@media`：媒体查询（实现响应式布局的一种方案）
	>`@font-face`：导入字体图标

##响应式布局开发
	>响应式布局：
	>- 在不同尺寸的设备上都能良好的展示，这就是响应式布局设计（Responsive Layout）
	>如何实现响应式布局开发：
	>- 最常用的方案：REM等比缩放响应式布局
	>做移动端`H5`开发，首先加`meta`标签
	>`<meta name="viewport" content="width=device-width,initial-scale=1.0">`
	>`rem`和`px`都是样式单位，`px`是固定单位，`rem`是相对单位（相对与当前页面根元素`html`的`font-size`字体设定的单位，如果`font-size=100px`那么`1rem=100px`,所有设置`rem`的元素都会跟随放大缩小）
	>真实项目中设计师给我们一套设计稿（常用的尺寸：640*1136、750*1334、640*960....），拿到设计稿后，我们严格按照设计稿中的尺寸去编写样式
	```
	html{font-size:100px;}
	```
	>接下来写样式，把测量出来的px都除以100变为rem，所有的单位基于rem来搞=>假设设计稿是750，也就相当于750的设备下，1rem=100px
	>我们页面运行在320的设备上，我们需要修改html的字体大小，以此实现页面跟着整体缩放：320/750*100=>当前设备上html的字体大小

	>公司中的产品形态
	>1、`PC`端（全屏页面需要宽度自适应，但是一般都是固定宽度的）
	>2、`PC`+移动端 用同一套项目（简单的页面，例如：产品介绍，公司展示类的官网等）
	>3、移动端（移动端设备尺寸差异较大，需要做响应式布局开发）
	>嵌入到`APP`中的`H5`、微信中分享出来的`H5`、微信公众号、小程序、靠浏览器访问的`H5`
	>4、`RN（Reat Native）/ ionic / cordova...` `Js`开发`APP`的框架，使用`JS`代码开发APP，最后框架会把代码转换为安卓和`IOS`需要的代码

#移动端zepto插件
	>`zepto`和`JQ`的区别：
	>1、`zepto`没有考虑浏览器的兼容，专门为移动端开发的小型类库，也仅仅是把`JQ`中的一些常规方法实现了，很多方法也没有实现（例如:`slideDown/show...`在`zepto`中没有）为了保证`zepto`的体积足够小
	>2、`zepto`中提供了移动端专门操作的事件方法（例如：`tap`等），这些方法都是基于移动端的`touch`和`gesture`事件模型封装好的方法，`JQ`中并没有提供这些方法=>`zepto`更适合移动端
	>`$class.tap(ev=>{});`：点击
	>`$class.singleTap(ev=>{});`：单击
	>`$class.doubleTap(ev=>{});`：双击
	>`$class.longTap(ev=>{});`：长按
	>`$class.swipe(ev=>{});`：滑动
	>`$class.swipeLeft(ev=>{});`：左滑动
	>`$class.swipeRight(ev=>{});`：右滑动
	>`$class.swipeUp(ev=>{});`：上滑动
	>`$class.swipeDown(ev=>{});`：下滑动
	>`$class.pinchIn(ev=>{});`：缩小
	>`$class.pinchOut(ev=>{});`：放大

#响应式
	>`viewport`：视口

	>`layout viewport`：布局页面视口（和开发`CSS`等相关）
	>`visual viewport`：手机视口
	>`ideal viewport`：理想视口

	>`HTML`的宽度>手机宽度=>把页面整体缩放
	>页面内容宽度>`HTML`页面的宽度=>出现横向滚动条

	>真实移动端项目开发中，一般是不会出现横向滚动条的，想让他出现横向滚动条就要保证内容的宽度不会超过`HTML`页面的宽度
	>移动端开发手机设备宽度不一定->`HTML`页面的宽度也不一定->所以内容的宽度一般也不是固定的（也就是所谓的百分比宽度）
	>移动端开发（流式响应式布局方案）：外层盒子的宽度一般都是百分比设定的，很少有些固定的值（里面具体的小元素宽度可以固定）

	>平时处理的移动端项目：
>1、`PC`端和移动端公用一套项目（结构相对简单，一般都是展示类的企业站）
	>【设计师一般只给一套设计稿】
	>开发流程：`PC`端（一般宽度都是自适应，具体情况有所不同）->移动端（使用`@media`媒体查询，把不同设备上不合适的样式进行修改）
	>我们可以把`@media`理解为`JS`中的条件判断，在不同条件使用不同的`CSS`样式进行渲染
	>`@media`[媒体设备] `and`[媒体条件] `and`[媒体条件]......
	>`@media all`：所有设备
	>`@media screen`：所有屏幕设备（`PC`+电脑）
	>`@media screen and(orientation:portrait)`：条件匹配横屏变竖屏（宽<高）
	>`@media screen and(orientation:landscape)`：条件匹配竖屏变横屏（宽>高）
	>`@media print`：打印设备
	```
	media all and(max-width:780px){
		//页面宽度最大是780px的时候使用以下样式
		.box{
			width:200px;
		}
	}
	media all and(max-width:640px){
		//页面宽度最大是640px的时候使用以下样式
		.box{
			width:150px;
		}
	}
	media all and(max-width:480px){
		//页面宽度最大是480px的时候使用以下样式
		.box{
			width:200px;
		}
	}
	```

>2、`PC`端和移动端是分开的两套不同项目
	>【设计师一般会给两套设计稿（`PC`+移动）】
	>- `PC`端单独做（不需要考虑移动端响应式）：固定式布局

	>- 移动端单独做（只需要考虑移动端的响应式适配）：响应式布局
	>依然可以基于`@media`来处理（麻烦一些）
	>固定布局（`viewport`=>`width=320px`）；按照设计稿把320尺寸的写好即可（所有的尺寸都可以固定，而且都是设计稿的一半，因为设计稿是大一倍的），在其它的设备上让`320px`的页面剧中展示即可
	>`scale`等比缩放布局（严格按照设计稿的尺寸来写样式，没有自适应宽度，都是固定值，在其它设备上，首先获取设备的宽度，让其除以设计稿的宽度，然后让原始写好的页面按照这个比例整体缩小即可）=>会导致一些问题例如字体变模糊
	>`rem`等比缩放：它是参考`scale`，只是用的`rem`单位来实现的等比缩放（严格按照设计稿的尺寸编写，但是一般宽度让他自适应，其余的值可以写固定值->在编写`css`样式的时候，我们把所有的`px`单位都换算成`rem`单位->当加载页面的时候，根据当前设备的尺寸除以设计稿，根据比例动态调整`rem`和`px`的换算比例）
	>`CSS 3`中提供了`flex-box`伸缩盒子模型，基于这个属性，可以让某些效果处理起来更加方便

	>- 设计师给的移动端设计稿一般都是：640*1136（980或者不确定高度）、750*1334...
	>为什么设计稿比参照的手机大一倍？
	>目的是保证切下来的素材资源图片都是大图
	>为什么保证大图？
	>因为很多手机都是二倍及三倍屏幕像素密度比（DPR）的
	>即使给的是二倍设计稿，但是部分手机的设备尺寸要大于设计稿的一半，有的手机是3倍`DPR`的，这样就导致一个问题：部分图片还是会变的模糊一些，此时我们找设计师单独的把模糊图片要一张大图即可

	>在`PC`端，我们开发的`HTML`页面运行在浏览器中，浏览器有多宽（一般浏览器代表设备的宽度）`HTML`就有多宽，也就是在浏览器宽度的视口中渲染和呈现我们的页面
	>移动端和`PC`端的区别：不管移动端设备（代指打开的浏览器）的宽度是多少，`HTMl`页面的宽度是980（或者1024）=>导致的问题：如果在设备窗口中想把整个页面完全呈现出来（小窗口中完全展示大页面），我们只能把大页面进行缩放，`HTML`页面缩放了，那么页面中所有内容都缩放了
	>解决方案
	>只要让`H5`页面的宽度和手机设备宽度保持一致即可，就不会出现手机渲染页面的时候把页面缩放的事情了
	`<meta name="viewport" content="width=device-width, initial-scale=1.0">`
	>此`meta`标签就是在设置子`VP`（视口）的规则
	>`width=device-width`：让`HTML`页面的宽度等于设备的宽度
	>`height=device-height`：设置`HTML`页面的高度（一般不用）
	>`initial-scale=1.0`：初始缩放比例是1：1（也就是既不放大也不缩小）
	>`user-scalable=no`：禁止用户手动缩放（部分安卓机中只设置）`user-scalable`是不起作用的，需要同这两个（`maximum-scale/minimum-scale`）一起使用
	>`maximum-scale=1.0`：设置最大的缩放比例1：1（既不放大也不缩小）
	>`minimum-scale=1.0`：设置最小的缩放比例1：1（既不放大也不缩小）